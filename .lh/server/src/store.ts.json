{
    "sourceFile": "server/src/store.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1763697963956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1763697969990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n       const result = await redisClient.scan(cursor.toString(), {\n         MATCH: 'group:*',\n         COUNT: 100\n       })\n-      cursor = result.cursor\n+      cursor = parseInt(result.cursor, 10)\n       groupKeys.push(...result.keys.filter(key => !key.includes(':members')))\n     } while (cursor !== 0)\n \n     const groups: Group[] = []\n"
                }
            ],
            "date": 1763697963956,
            "name": "Commit-0",
            "content": "import { redisClient } from './redis'\nimport { User, ConnectedClient, Message, Group } from './types'\n\nexport class DataStore {\n  private connectedClients: Map<string, ConnectedClient> = new Map()\n\n  // User methods\n  async createUser(user: User): Promise<void> {\n    // Store user data\n    await redisClient.hSet(`user:${user.id}`, {\n      id: user.id,\n      username: user.username,\n      password: user.password\n    })\n    // Create username index\n    await redisClient.set(`user:username:${user.username}`, user.id)\n    // Add to users set\n    await redisClient.sAdd('users', user.id)\n  }\n\n  async getUserById(id: string): Promise<User | null> {\n    const userData = await redisClient.hGetAll(`user:${id}`)\n    if (!userData || !userData.id) return null\n    return userData as User\n  }\n\n  async getUserByUsername(username: string): Promise<User | null> {\n    const userId = await redisClient.get(`user:username:${username}`)\n    if (!userId) return null\n    return this.getUserById(userId)\n  }\n\n  async getAllUsers(): Promise<User[]> {\n    const userIds = await redisClient.sMembers('users')\n    const users: User[] = []\n\n    for (const userId of userIds) {\n      const user = await this.getUserById(userId)\n      if (user) users.push(user)\n    }\n\n    return users\n  }\n\n  // Connected clients methods (still in memory for WebSocket connections)\n  addConnectedClient(client: ConnectedClient): void {\n    this.connectedClients.set(client.userId, client)\n  }\n\n  removeConnectedClient(userId: string): void {\n    this.connectedClients.delete(userId)\n  }\n\n  getConnectedClient(userId: string): ConnectedClient | undefined {\n    return this.connectedClients.get(userId)\n  }\n\n  getAllConnectedClients(): ConnectedClient[] {\n    return Array.from(this.connectedClients.values())\n  }\n\n  // Message methods\n  async addMessage(message: Message): Promise<void> {\n    const messageData = {\n      id: message.id,\n      senderId: message.senderId,\n      senderName: message.senderName,\n      content: message.content,\n      type: message.type,\n      timestamp: message.timestamp.toString(),\n      status: message.status,\n      conversationId: message.conversationId,\n      isGroup: message.isGroup.toString()\n    }\n\n    await redisClient.hSet(`message:${message.id}`, messageData)\n    // Add to conversation messages list\n    await redisClient.lPush(`conversation:${message.conversationId}:messages`, message.id)\n  }\n\n  async getMessageById(id: string): Promise<Message | null> {\n    const messageData = await redisClient.hGetAll(`message:${id}`)\n    if (!messageData || !messageData.id) return null\n\n    return {\n      id: messageData.id,\n      senderId: messageData.senderId,\n      senderName: messageData.senderName,\n      content: messageData.content,\n      type: messageData.type as 'text' | 'image',\n      timestamp: parseInt(messageData.timestamp),\n      status: messageData.status as 'sent' | 'delivered' | 'read',\n      conversationId: messageData.conversationId,\n      isGroup: messageData.isGroup === 'true'\n    }\n  }\n\n  async updateMessageStatus(messageId: string, status: 'sent' | 'delivered' | 'read'): Promise<void> {\n    await redisClient.hSet(`message:${messageId}`, 'status', status)\n  }\n\n  async getConversationMessages(conversationId: string, limit: number = 50): Promise<Message[]> {\n    const messageIds = await redisClient.lRange(`conversation:${conversationId}:messages`, 0, limit - 1)\n    const messages: Message[] = []\n\n    for (const messageId of messageIds) {\n      const message = await this.getMessageById(messageId)\n      if (message) messages.push(message)\n    }\n\n    return messages.reverse() // Oldest first\n  }\n\n  // Group methods\n  async createGroup(group: Group): Promise<void> {\n    const groupData = {\n      id: group.id,\n      name: group.name,\n      createdBy: group.createdBy,\n      createdAt: group.createdAt.toString()\n    }\n\n    await redisClient.hSet(`group:${group.id}`, groupData)\n\n    // Add members\n    if (group.members.length > 0) {\n      await redisClient.sAdd(`group:${group.id}:members`, group.members)\n    }\n\n    // Add to each user's groups\n    for (const memberId of group.members) {\n      await redisClient.sAdd(`user:${memberId}:groups`, group.id)\n    }\n  }\n\n  async getGroupById(id: string): Promise<Group | null> {\n    const groupData = await redisClient.hGetAll(`group:${id}`)\n    if (!groupData || !groupData.id) return null\n\n    const members = await redisClient.sMembers(`group:${id}:members`)\n\n    return {\n      id: groupData.id,\n      name: groupData.name,\n      members: members,\n      createdBy: groupData.createdBy,\n      createdAt: parseInt(groupData.createdAt)\n    }\n  }\n\n  async getUserGroups(userId: string): Promise<Group[]> {\n    const groupIds = await redisClient.sMembers(`user:${userId}:groups`)\n    const groups: Group[] = []\n\n    for (const groupId of groupIds) {\n      const group = await this.getGroupById(groupId)\n      if (group) groups.push(group)\n    }\n\n    return groups\n  }\n\n  async addGroupMember(groupId: string, userId: string): Promise<void> {\n    await redisClient.sAdd(`group:${groupId}:members`, userId)\n    await redisClient.sAdd(`user:${userId}:groups`, groupId)\n  }\n\n  async getAllGroups(): Promise<Group[]> {\n    // Scan for all group keys\n    const groupKeys: string[] = []\n    let cursor = 0\n\n    do {\n      const result = await redisClient.scan(cursor.toString(), {\n        MATCH: 'group:*',\n        COUNT: 100\n      })\n      cursor = result.cursor\n      groupKeys.push(...result.keys.filter(key => !key.includes(':members')))\n    } while (cursor !== 0)\n\n    const groups: Group[] = []\n    for (const key of groupKeys) {\n      const groupId = key.replace('group:', '')\n      const group = await this.getGroupById(groupId)\n      if (group) groups.push(group)\n    }\n\n    return groups\n  }\n}\n\nexport const store = new DataStore()\n"
        }
    ]
}